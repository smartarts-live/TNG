<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>brain-TRAINer! - Fun-Break</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%23F39C12'/><text x='50%' y='50%' font-family='Arial, sans-serif' font-size='50' font-weight='bold' fill='%23FFFFFF' dominant-baseline='central' text-anchor='middle'>CP</text></svg>">
    <style>
        :root {
            --primary: #2C3E50;
            --fun: #F39C12;
            --bg: #1a1a1a;
            --text: #FFFFFF;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
            user-select: none;
        }

        h2 { color: var(--fun); margin: 0 0 10px 0; font-size: 1.5rem; letter-spacing: 2px;}
        #score-display { font-size: 1.2rem; margin-bottom: 20px; font-weight: bold; color: #ccc;}

        canvas {
            background-color: #000;
            border: 4px solid var(--primary);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.2);
            max-width: 100%;
        }

        /* Mobile Controls */
        .controls {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px;
            gap: 10px;
            margin-top: 30px;
        }

        .ctrl-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: white;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.1s;
        }
        .ctrl-btn:active { background: rgba(255, 255, 255, 0.3); }

        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-down { grid-column: 2; grid-row: 2; }
        .btn-right { grid-column: 3; grid-row: 2; }

        /* Game Over Overlay */
        #game-over-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            padding: 20px;
        }

        #game-over-screen h1 { color: #E74C3C; font-size: 3rem; margin-bottom: 10px; }
        .redirect-text { font-size: 1.5rem; color: #FFF; margin-top: 20px; }
        #countdown { color: var(--fun); font-size: 4rem; font-weight: bold; margin-top: 10px; }

    </style>
</head>
<body>

    <h2 id="game-title">LÄDT...</h2>
    <div id="score-display">Punkte: <span id="score">0</span></div>

    <canvas id="gameCanvas" width="300" height="400"></canvas>

    <div class="controls">
        <div class="ctrl-btn btn-up" id="btn-up">▲</div>
        <div class="ctrl-btn btn-left" id="btn-left">◀</div>
        <div class="ctrl-btn btn-down" id="btn-down">▼</div>
        <div class="ctrl-btn btn-right" id="btn-right">▶</div>
    </div>

    <div id="game-over-screen">
        <h1>GAME OVER</h1>
        <p class="redirect-text">Die Pause ist vorbei. Zurück zum Training in:</p>
        <div id="countdown">3</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let score = 0;
        let isGameOver = false;
        let gameInterval;
        let gameAnimFrame;

        // --- GLOBAL GAME OVER & REDIRECT LOGIC ---
        function triggerGameOver() {
            if(isGameOver) return;
            isGameOver = true;
            clearInterval(gameInterval);
            cancelAnimationFrame(gameAnimFrame);
            
            document.getElementById('game-over-screen').style.display = 'flex';
            
            let timeLeft = 3;
            document.getElementById('countdown').innerText = timeLeft;
            
            let redirectInterval = setInterval(() => {
                timeLeft--;
                if(timeLeft > 0) {
                    document.getElementById('countdown').innerText = timeLeft;
                } else {
                    clearInterval(redirectInterval);
                    window.location.href = 'index.html'; // Auto-Redirect zum Training
                }
            }, 1000);
        }

        // --- INPUT MAPPER ---
        let currentInput = null;
        
        // Keyboard
        document.addEventListener('keydown', (e) => {
            if(['ArrowUp', 'w', 'W'].includes(e.key)) currentInput = 'UP';
            if(['ArrowDown', 's', 'S'].includes(e.key)) currentInput = 'DOWN';
            if(['ArrowLeft', 'a', 'A'].includes(e.key)) currentInput = 'LEFT';
            if(['ArrowRight', 'd', 'D'].includes(e.key)) currentInput = 'RIGHT';
        });

        // Touch / Click
        ['up', 'down', 'left', 'right'].forEach(dir => {
            const btn = document.getElementById(`btn-${dir}`);
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); currentInput = dir.toUpperCase(); });
            btn.addEventListener('mousedown', (e) => { e.preventDefault(); currentInput = dir.toUpperCase(); });
        });

        // --- RANDOM GAME SELECTOR ---
        const games = ['snake', 'pong', 'tetris'];
        const selectedGame = games[Math.floor(Math.random() * games.length)];
        
        if (selectedGame === 'snake') initSnake();
        else if (selectedGame === 'pong') initPong();
        else if (selectedGame === 'tetris') initTetris();

        // ==========================================
        // GAME 1: SNAKE
        // ==========================================
        function initSnake() {
            document.getElementById('game-title').innerText = "SNAKE";
            const gridSize = 15;
            let snake = [{x: 10, y: 10}];
            let dx = 0, dy = -1;
            let apple = {x: 5, y: 5};
            
            function placeApple() {
                apple.x = Math.floor(Math.random() * (canvas.width / gridSize));
                apple.y = Math.floor(Math.random() * (canvas.height / gridSize));
            }
            
            gameInterval = setInterval(() => {
                if(isGameOver) return;
                
                // Direction change
                if(currentInput === 'UP' && dy === 0) { dx = 0; dy = -1; }
                else if(currentInput === 'DOWN' && dy === 0) { dx = 0; dy = 1; }
                else if(currentInput === 'LEFT' && dx === 0) { dx = -1; dy = 0; }
                else if(currentInput === 'RIGHT' && dx === 0) { dx = 1; dy = 0; }
                currentInput = null; // Consume input

                const head = {x: snake[0].x + dx, y: snake[0].y + dy};
                
                // Wall collision
                if(head.x < 0 || head.x >= canvas.width/gridSize || head.y < 0 || head.y >= canvas.height/gridSize) {
                    triggerGameOver(); return;
                }
                
                // Self collision
                for(let part of snake) {
                    if(head.x === part.x && head.y === part.y) { triggerGameOver(); return; }
                }

                snake.unshift(head);

                // Apple collision
                if(head.x === apple.x && head.y === apple.y) {
                    score += 10;
                    document.getElementById('score').innerText = score;
                    placeApple();
                } else {
                    snake.pop();
                }

                // Draw
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#E74C3C'; // Apple
                ctx.fillRect(apple.x*gridSize, apple.y*gridSize, gridSize-1, gridSize-1);
                
                ctx.fillStyle = '#27AE60'; // Snake
                snake.forEach(part => {
                    ctx.fillRect(part.x*gridSize, part.y*gridSize, gridSize-1, gridSize-1);
                });

            }, 100);
        }

        // ==========================================
        // GAME 2: RALLY PONG (Single Player)
        // ==========================================
        function initPong() {
            document.getElementById('game-title').innerText = "RALLY PONG";
            // Disable Left/Right buttons visually
            document.getElementById('btn-left').style.opacity = '0.2';
            document.getElementById('btn-right').style.opacity = '0.2';

            const paddle = { x: 10, y: 150, width: 10, height: 60, dy: 5 };
            const ball = { x: 150, y: 200, r: 5, dx: 3, dy: 3 };
            
            function loop() {
                if(isGameOver) return;
                
                // Move Paddle
                if(currentInput === 'UP' && paddle.y > 0) paddle.y -= paddle.dy;
                if(currentInput === 'DOWN' && paddle.y + paddle.height < canvas.height) paddle.y += paddle.dy;
                // Don't consume input so it can be held down

                // Move Ball
                ball.x += ball.dx;
                ball.y += ball.dy;

                // Bounce top/bottom
                if(ball.y - ball.r < 0 || ball.y + ball.r > canvas.height) ball.dy *= -1;
                // Bounce right wall
                if(ball.x + ball.r > canvas.width) {
                    ball.x = canvas.width - ball.r;
                    ball.dx *= -1;
                }

                // Paddle collision
                if(ball.x - ball.r < paddle.x + paddle.width && ball.y > paddle.y && ball.y < paddle.y + paddle.height) {
                    ball.x = paddle.x + paddle.width + ball.r;
                    ball.dx *= -1.05; // Speed up slightly
                    score++;
                    document.getElementById('score').innerText = score;
                }

                // Missed
                if(ball.x < 0) { triggerGameOver(); return; }

                // Draw
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FFF';
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height); // Paddle
                ctx.fillRect(canvas.width - 5, 0, 5, canvas.height); // Right Wall
                
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
                ctx.fill();

                gameAnimFrame = requestAnimationFrame(loop);
            }
            loop();
        }

        // ==========================================
        // GAME 3: TETRIS (Simplified)
        // ==========================================
        function initTetris() {
            document.getElementById('game-title').innerText = "TETRIS BLOCKS";
            const ROWS = 20; const COLS = 10; const SQ = 20; // 10x20 grid, 20px squares
            
            // Center canvas content (canvas is 300x400, grid is 200x400)
            const offsetX = (canvas.width - (COLS * SQ)) / 2;

            const board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
            
            const shapes = [
                [[1,1,1,1]], // I
                [[1,1],[1,1]], // O
                [[0,1,0],[1,1,1]], // T
                [[1,0,0],[1,1,1]], // L
                [[0,0,1],[1,1,1]], // J
                [[1,1,0],[0,1,1]], // S
                [[0,1,1],[1,1,0]]  // Z
            ];
            const colors = ['#000', '#3498DB', '#F1C40F', '#9B59B6', '#E67E22', '#2980B9', '#2ECC71', '#E74C3C'];

            let piece = generatePiece();
            let dropCounter = 0;
            let dropInterval = 500;
            let lastTime = Date.now();

            function generatePiece() {
                const id = Math.floor(Math.random() * shapes.length);
                const shape = shapes[id];
                return { shape: shape, colorId: id + 1, x: Math.floor(COLS/2) - Math.floor(shape[0].length/2), y: 0 };
            }

            function rotate(matrix) {
                return matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
            }

            function collide(p, testX, testY, testShape) {
                const shape = testShape || p.shape;
                for(let r=0; r<shape.length; r++){
                    for(let c=0; c<shape[r].length; c++){
                        if(shape[r][c] !== 0) {
                            let newX = testX + c; let newY = testY + r;
                            if(newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX] !== 0)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function merge() {
                piece.shape.forEach((row, r) => {
                    row.forEach((val, c) => {
                        if(val !== 0) board[piece.y + r][piece.x + c] = piece.colorId;
                    });
                });
            }

            function clearLines() {
                let linesCleared = 0;
                for(let r = ROWS - 1; r >= 0; r--) {
                    if(board[r].every(val => val !== 0)) {
                        board.splice(r, 1);
                        board.unshift(Array(COLS).fill(0));
                        linesCleared++;
                        r++; // Check same row index again
                    }
                }
                if(linesCleared > 0) {
                    score += linesCleared * 100;
                    document.getElementById('score').innerText = score;
                    dropInterval = Math.max(100, dropInterval - 20); // Speed up
                }
            }

            function update() {
                if(isGameOver) return;
                
                // Handle Input
                if(currentInput) {
                    if(currentInput === 'LEFT' && !collide(piece, piece.x - 1, piece.y)) piece.x--;
                    if(currentInput === 'RIGHT' && !collide(piece, piece.x + 1, piece.y)) piece.x++;
                    if(currentInput === 'DOWN' && !collide(piece, piece.x, piece.y + 1)) piece.y++;
                    if(currentInput === 'UP') {
                        const rotated = rotate(piece.shape);
                        if(!collide(piece, piece.x, piece.y, rotated)) piece.shape = rotated;
                    }
                    currentInput = null;
                }

                // Handle Drop
                const now = Date.now();
                const delta = now - lastTime;
                dropCounter += delta;
                lastTime = now;

                if(dropCounter > dropInterval) {
                    if(!collide(piece, piece.x, piece.y + 1)) {
                        piece.y++;
                    } else {
                        if(piece.y === 0) { triggerGameOver(); return; } // Top out
                        merge();
                        clearLines();
                        piece = generatePiece();
                    }
                    dropCounter = 0;
                }

                draw();
                gameAnimFrame = requestAnimationFrame(update);
            }

            function draw() {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height); // BG
                ctx.fillStyle = '#000';
                ctx.fillRect(offsetX, 0, COLS * SQ, ROWS * SQ); // Board Area
                
                // Draw Board
                for(let r=0; r<ROWS; r++){
                    for(let c=0; c<COLS; c++){
                        if(board[r][c] !== 0) {
                            ctx.fillStyle = colors[board[r][c]];
                            ctx.fillRect(offsetX + c*SQ, r*SQ, SQ-1, SQ-1);
                        }
                    }
                }
                // Draw Piece
                piece.shape.forEach((row, r) => {
                    row.forEach((val, c) => {
                        if(val !== 0) {
                            ctx.fillStyle = colors[piece.colorId];
                            ctx.fillRect(offsetX + (piece.x + c)*SQ, (piece.y + r)*SQ, SQ-1, SQ-1);
                        }
                    });
                });
            }

            lastTime = Date.now();
            update();
        }
    </script>
</body>
</html>
